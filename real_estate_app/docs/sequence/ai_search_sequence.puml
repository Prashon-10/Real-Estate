@startuml AI_Search_Sequence

title AI-Powered Property Search Process

actor Customer as customer
participant "Frontend (React)" as frontend
participant "Search Views" as search_views
participant "AI Service" as ai_service
participant "Sentence Transformers" as transformers
participant "Property (Model)" as property_model
participant "SearchHistory (Model)" as history_model
participant "Recommendation (Model)" as recommendation_model
database "Database" as db

== Customer Initiates Search ==
customer -> frontend : Enter search: "luxury apartment downtown with balcony"
frontend -> search_views : POST /search/

== Log Search Activity ==
search_views -> history_model : create(user, query)
history_model -> db : INSERT INTO search_history
db --> history_model : Search logged
history_model --> search_views : History saved

== Basic Keyword Search ==
search_views -> property_model : keyword_search(query)
property_model -> db : SELECT * FROM properties WHERE title LIKE '%luxury%' OR description LIKE '%apartment%'
db --> property_model : Basic results
property_model --> search_views : Keyword matches

== AI Semantic Search ==
search_views -> ai_service : semantic_search(query, basic_results)
ai_service -> transformers : encode_query("luxury apartment downtown with balcony")
transformers --> ai_service : Query embedding vector

ai_service -> property_model : get_all_properties()
property_model -> db : SELECT id, title, description FROM properties WHERE status='available'
db --> property_model : All property texts
property_model --> ai_service : Property descriptions

ai_service -> transformers : encode_properties(property_descriptions[])
transformers --> ai_service : Property embedding vectors

ai_service -> ai_service : calculate_cosine_similarity(query_vector, property_vectors)
ai_service -> ai_service : rank_by_similarity(properties, similarity_scores)
ai_service --> search_views : Ranked search results

== Update Recommendations ==
search_views -> recommendation_model : update_recommendations(user, search_results)
loop For each relevant property
    recommendation_model -> recommendation_model : calculate_relevance_score(user_behavior, property)
    recommendation_model -> db : INSERT OR UPDATE recommendations
    db --> recommendation_model : Recommendation saved
end
recommendation_model --> search_views : Recommendations updated

== Return Results to Customer ==
search_views -> property_model : enrich_results_with_metadata(search_results)
property_model -> db : Get property images, agent info, favorites status
db --> property_model : Complete property data
property_model --> search_views : Enriched results

search_views --> frontend : JSON response with ranked results
frontend --> customer : Display Search Results with Relevance Scores

== Handle AI Service Failures ==
alt AI Service Available
    note right : Normal AI-powered search flow
else AI Service Unavailable
    search_views -> property_model : fallback_to_basic_search(query)
    property_model -> db : Simple text search
    db --> property_model : Basic results
    property_model --> search_views : Fallback results
    search_views --> frontend : Basic search results
    frontend --> customer : Show results (basic mode)
end

== Track User Interaction ==
customer -> frontend : Click on property result
frontend -> search_views : GET /properties/{id}
search_views -> history_model : create(user, property_view, property_id)
history_model -> db : Log property view
db --> history_model : Interaction logged
history_model --> search_views : Tracking complete

note right of transformers
    Uses all-MiniLM-L6-v2 model
    for semantic understanding:
    - Converts text to 384-dim vectors
    - Captures semantic meaning
    - Enables similarity matching
end note

note right of ai_service
    Similarity calculation:
    - Cosine similarity between vectors
    - Threshold filtering (>0.2)
    - Ranking by relevance score
    - Fallback to keyword search
end note

@enduml
